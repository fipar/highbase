#!/bin/bash
#
# mysql-had
# this file is part of the mysql-ha suite (named rc-script on the cvs tree)

# Copyright 2002 Fernando Ipar - fipar@acm.org / fipar@users.sourceforge.net

# This program is free software; you can redistribute it
# and/or modify it under the terms of the GNU General Public
# License as published by the Free Software Foundation;
# either version 2 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
# PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public
# License along with this program; if not, write to the Free
# Software Foundation, Inc., 59 Temple Place, Suite 330,
# Boston, MA 02111-1307 USA

### BEGIN INIT INFO
# Provides:          mysql-ha
# Required-Start:    
# Required-Stop:     
# Should-Start:      
# Should-Stop:       
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Start and stop the mysql-ha daemon 
# Description:  mysql-ha is a high availability clustering system for use 
# with the mysql database server. it uses mysql's builtin replication 
# features to achieve data redundance, fake to migrate a unique cluster IP 
# from master to slave in the event of a failure, and is highly customizable 
# and in active development
     
#                    
### END INIT INFO


# chkconfig: 2345 98 88
# description: mysql-ha is a high availability clustering system for use \
# with the mysql database server. it uses mysql's builtin replication \
# features to achieve data redundance, fake to migrate a unique cluster IP \
# from master to slave in the event of a failure, and is highly customizable \
# and in active development
# processname: mysql-had
# config: /etc/mysql-ha.conf
# pidfile: /var/run/mysql-ha.pid

export MYSQLHA_HOME=/usr/mysql-ha
#FIXME: figure out a way to get this out of the installation process

. /etc/profile # so we get the path

progname=$(basename $0)
pidf="/var/run/mysql-ha.pid"
logf="/var/log/mysql-ha.log"
startedname="$MYSQLHA_HOME/configurator.sh"

. $MYSQLHA_HOME/role.include
. $MYSQLHA_HOME/compat.sh
. $MYSQLHA_HOME/common.sh


start()
{
	[ -f $pidf ] && echo "$progname already running (found pid file)">&2 && return 1
	echo -n "starting $progname: ">&2
	USER=$(cat $MYSQLHA_HOME/ssh_user)
	chown $USER.$USER $logf
	touch $pidf
	chown $USER.$USER $pidf
	encrypted=0
	grep ENCRYPTED /home/$USER/.ssh/id_dsa >/dev/null && {
		encrypted=1
		su - $USER -c "cd $MYSQLHA_HOME; env MYSQLHA_HOME=$MYSQLHA_HOME ./configurator.sh -o start-agent"	
	}
	nohup su - $USER -c "cd $MYSQLHA_HOME; env MYSQLHA_HOME=$MYSQLHA_HOME ./configurator.sh -p $pidf -e $encrypted>>$logf 2>&1" & >/dev/null 2>&1
	[ -f $pidf ] && {
		[ -d /proc/$(cat $pidf) ] && echo "OK">&2 || {
			echo "ERROR ($(cat $pidf) does not appear to be running)">&2
			return 1
		}
	} || echo "ERROR ($pidf not found after nohup)">&2 && return 1
	return 0
}

stop()
{
	[ -f $pidf ] || {
		echo "$progname does not appear to be running (pid fil not found)">&2
		return 1
	}

AGENT_SOCK=/tmp/mysql-ha-ssh-agent.sock

[ -n "$(fuser $AGENT_SOCK)" ] && {
	kill $(fuser $AGENT_SOCK 2>&1|awk -F: '{print $2}') >/dev/null 2>&1
	$SLEEP $(extractTime 200)
	kill -9 $(fuser $AGENT_SOCK 2>&1|awk -F: '{print $2}') >/dev/null 2>&1
}

	echo -n "stopping $progname: ">&2
	su - $USER -c "cd $MYSQLHA_HOME; env MYSQLHA_HOME=$MYSQLHA_HOME ./configurator.sh -o shutdown-master" >/dev/null 2>&1
	pid=$(cat $pidf)
	#cat $pidf
	#echo $pidf
	echo "\$3 == $pid {print \$2}" > /tmp/awkscr.$$ # TODO: learn to escape AWK scripts 
	ps -ef|awk -f /tmp/awkscr.$$ |xargs kill >/dev/null 2>&1#kill the children
	$SLEEP $(extractTime 30ms)
	ps -ef|awk -f /tmp/awkscr.$$ |xargs kill -9 >/dev/null 2>&1#i mean it
	rm -f /tmp/awkscr.$$
	kill $(cat $pidf)	
	sleep 1
	[ -d /proc/$(cat $pidf) ] && {
		kill -9 $(cat $pidf) >/dev/null 2>&1
		echo "OK (had to kill -9)">&2
	} || echo "OK">&2
	rm -f $pidf
	return 0
}


restart() 
{
  	stop
	start
}	


status()
{
	[ -f $pidf ] && {
		echo "$progname is running ($(cat $pidf))">&2
	} || {
		echo "$progname is not running (no pidfile)">&2
	}
}

case "$1" in
  start)
  	start
	;;
  stop)
  	stop
	;;
  restart)
  	restart
	;;
  status)
  	status
	;;
  *)
	echo "Usage: $0 {start|stop|restart|status}"
	exit 1
esac

exit $?
